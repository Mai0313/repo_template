package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"time"
)

func main() {
	reader := bufio.NewReader(os.Stdin)

	owner := promptRequired(reader, "Project owner", "e.g. Mai0313")
	rawName := promptRequired(reader, "Project name", "e.g. My Project")
	projName := strings.ToLower(strings.ReplaceAll(rawName, " ", "_"))

	pyVersion := promptDefault(reader, "Python version", "3.10")
	desc := promptDefault(reader, "Project description", "Generated by Repo Template")

	defEmail := getGitEmail()
	email := promptDefault(reader, "Author email", defEmail)
	licenseType := promptDefault(reader, "License type (MIT, Apache-2.0, GPL-3.0)", "MIT")

	if !commandExists("uv") {
		fmt.Println("Installing uv...")
		installUV()
	}

	// Clone template quietly
	timeStamp := time.Now().Format("20060102150405")
	tempDir := filepath.Join(os.TempDir(), "repo_template_"+timeStamp)
	fmt.Println("Cloning template...")
	execQuiet("git", "clone", "https://github.com/Mai0313/repo_template.git", tempDir)

	// Prepare project directory
	dest := projName
	if err := os.Mkdir(dest, 0755); err != nil {
		log.Fatalf("Create project dir failed: %v", err)
	}

	// Copy all files
	copyDir(tempDir, dest)

	// Replace tokens
	year := time.Now().Year()
	replaceInFiles(dest, map[string]string{
		"Mai0313/repo_template": owner + "/" + projName,
		"repo_template":         projName,
		"RepoTemplate":          titleCase(rawName),
		"__DESCRIPTION__":       desc,
		"__EMAIL__":             email,
		"__YEAR__":              strconv.Itoa(year),
	})

	// Remove original git history
	os.RemoveAll(filepath.Join(dest, ".git"))

	// Pin Python version quietly
	fmt.Println("Pinning Python version...")
	execQuietIn(dest, "uv", "python", "pin", pyVersion)

	// Generate LICENSE
	lic := genLicense(licenseType, year, owner)
	ioutil.WriteFile(filepath.Join(dest, "LICENSE"), []byte(lic), 0644)

	// Initialize new git repo quietly
	fmt.Println("Initializing git repository...")
	execQuietIn(dest, "git", "init")
	execQuietIn(dest, "git", "add", ".")
	execQuietIn(dest, "git", "commit", "-m", "Initial commit")

	fmt.Printf("Project '%s' initialized in %s\n", rawName, dest)
}

// execQuiet runs a command without printing its stdout/stderr
func execQuiet(name string, args ...string) {
	cmd := exec.Command(name, args...)
	if err := cmd.Run(); err != nil {
		log.Fatalf("%s failed: %v", name, err)
	}
}

// execQuietIn runs a command in the given directory quietly
func execQuietIn(dir, name string, args ...string) {
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	if err := cmd.Run(); err != nil {
		log.Fatalf("%s in %s failed: %v", name, dir, err)
	}
}

func promptRequired(r *bufio.Reader, label, example string) string {
	for {
		fmt.Printf("%s (%s): ", label, example)
		input, _ := r.ReadString('\n')
		input = strings.TrimSpace(input)
		if input != "" {
			return input
		}
		fmt.Println("This field is required.")
	}
}

func promptDefault(r *bufio.Reader, label, def string) string {
	fmt.Printf("%s [default: %s]: ", label, def)
	input, _ := r.ReadString('\n')
	input = strings.TrimSpace(input)
	if input == "" {
		return def
	}
	return input
}

func getGitEmail() string {
	out, err := exec.Command("git", "config", "--get", "user.email").Output()
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(out))
}

func commandExists(name string) bool {
	_, err := exec.LookPath(name)
	return err == nil
}

func installUV() {
	switch runtime.GOOS {
	case "linux":
		execQuiet("sh", "-c", "curl -sSL https://get.uv.sh | bash")
	case "darwin":
		execQuiet("brew", "install", "uv")
	case "windows":
		execQuiet("powershell", "-Command", "Set-ExecutionPolicy Bypass -Scope Process; iex ((New-Object System.Net.WebClient).DownloadString('https://get.uv.ps1'))")
	default:
		log.Printf("Unsupported OS for auto-install: %s", runtime.GOOS)
	}
}

func copyDir(src, dst string) {
	filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		rel, _ := filepath.Rel(src, path)
		target := filepath.Join(dst, rel)
		if info.IsDir() {
			return os.MkdirAll(target, info.Mode())
		}
		r, err := os.Open(path)
		if err != nil {
			return err
		}
		defer r.Close()
		w, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, info.Mode())
		if err != nil {
			return err
		}
		defer w.Close()
		io.Copy(w, r)
		return nil
	})
}

func replaceInFiles(root string, repl map[string]string) {
	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return err
		}
		data, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}
		text := string(data)
		for old, new := range repl {
			text = strings.ReplaceAll(text, old, new)
		}
		ioutil.WriteFile(path, []byte(text), info.Mode())
		return nil
	})
}

func titleCase(s string) string {
	parts := strings.Fields(s)
	for i, p := range parts {
		parts[i] = strings.Title(p)
	}
	return strings.Join(parts, "")
}

func genLicense(typ string, year int, owner string) string {
	switch typ {
	case "MIT":
		return fmt.Sprintf(`MIT License

Copyright (c) %d %s

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction...
`, year, owner)
	case "Apache-2.0":
		return fmt.Sprintf(`Copyright %d %s

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy at http://www.apache.org/licenses/LICENSE-2.0
`, year, owner)
	case "GPL-3.0":
		return fmt.Sprintf(`Copyright (C) %d %s

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.
`, year, owner)
	default:
		return ""
	}
}
